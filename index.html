<!DOCTYPE html>
<html lang="en">
  <head>
  <title>6.849 - EDGE UNFOLDER</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link rel="stylesheet" href="css/main.css">
  <script src="js/polyhedra.js"></script>
  <script src="js/disjoint-set.js"></script>
  <script src="js/export.js"></script>
  </head>
  <body>

    <div id="info" style="font-size: 24px;">
      EDGE UNFOLDER<br/><span id="polyhedron_name" style="font-size:20px; color: #ff0;"></span>
    </div>
    <a id="downloadAnchorElem" style="display:none"></a>


  <script type="module">

  import * as THREE from 'https://unpkg.com/three@0.121.1/build/three.module.js';

  import { GUI } from 'https://unpkg.com/three@0.121.1/examples/jsm/libs/dat.gui.module.js';

  import { OrbitControls } from 'https://unpkg.com/three@0.121.1/examples/jsm/controls/OrbitControls.js';

  var group, camera, scene, renderer, raycaster;

  var polyhedron;
  var edges = {};

  var parameters = {
    exportToFold: function() {
      let fold = exportToFold(polyhedron, edges);
      //https://stackoverflow.com/questions/19721439/download-json-object-as-a-file-from-browser
      var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(fold));
      var dlAnchorElem = document.getElementById('downloadAnchorElem');
      dlAnchorElem.setAttribute("href",     dataStr     );
      dlAnchorElem.setAttribute("download", "edge-unfolder.fold");
      dlAnchorElem.click();
    },
    simulate: function() {
      simulate(polyhedron, edges);
    },
  };


  const mouse = new THREE.Vector2();
  var edgeMaterial = new THREE.MeshLambertMaterial( {
    color: 0xff0000
  } );
  var edgeMaterialSelected = new THREE.MeshLambertMaterial( {
    color: 0x00ff00
  } );



  init();
  animate();

  function init() {

    scene = new THREE.Scene();

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    //renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    // camera

    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
    camera.position.set( -1, -2, 3 );
    scene.add( camera );

    // controls

    var controls = new OrbitControls( camera, renderer.domElement );
    controls.maxDistance = 500;
    //controls.maxPolarAngle = Math.PI / 2;

    scene.add( new THREE.AmbientLight( 0x222222 ) );

    // light

    var light = new THREE.PointLight( 0xffb7b7, 1 );
    light.position.set( 5, 5, 5 );
    camera.add( light );

    // Raycaster
    raycaster = new THREE.Raycaster();
		raycaster.params.Line.threshold = 0.1;

    group = new THREE.Group();
    scene.add( group );

    polyhedron = POLYHEDRA.J1;
    displayPolyhedron();

    // dat.GUI

    var gui = new GUI( { width: 250 } );

    // this code excerpt is taken from Lee Stemkoski
    // https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/Polyhedra.html
    var categoryFolders = {};
    for (var arg in POLYHEDRA) {
      var guiSection = gui;
      if ( POLYHEDRA[arg].hasOwnProperty("category") ) {
        var category = POLYHEDRA[arg].category[0];
        if ( !categoryFolders.hasOwnProperty(category) )
          categoryFolders[category] = gui.addFolder(category);
        guiSection = categoryFolders[category];
      }

      parameters[arg] = function() {};

      guiSection.add( parameters, arg )
        .name( arg )
        .onChange( function(value) {
          polyhedron = POLYHEDRA[this.property];
          displayPolyhedron();
        });
    }

    gui.add(parameters, 'exportToFold').name("Export to FOLD");
    gui.add(parameters, 'simulate').name("Origami Simulator");

    document.addEventListener( 'click', onClick, false );
    window.addEventListener( 'resize', onWindowResize, false );
  }

  function displayPolyhedron() {
    document.getElementById("polyhedron_name").innerHTML = polyhedron.name;

    while (group.children.length > 0) {
      group.remove(group.children[0]);
    }
    edges = {};

    var geometry = new THREE.Geometry();
    for (var i = 0; i < polyhedron.vertex.length; i++) {
      geometry.vertices.push(new THREE.Vector3(polyhedron.vertex[i][0], polyhedron.vertex[i][1], polyhedron.vertex[i][2]));
    }

    var new_f_to_old_f = [];
    for (var i = 0; i < polyhedron.face.length; i++) {
      var f = polyhedron.face[i];
      if (f.length == 3) {
        geometry.faces.push(new THREE.Face3(f[0], f[1], f[2]));
        new_f_to_old_f.push(i);
      } else {
        // do a simple triangulation
        // add a new vertex at the center
        var v = new THREE.Vector3(0, 0, 0);
        for (var j = 0; j < f.length; j++) {
          v.add(geometry.vertices[f[j]]);
        }
        v.divideScalar(f.length);
        var v_idx = geometry.vertices.length;
        geometry.vertices.push(v);

        for (var j = 0; j < f.length; j++) {
          geometry.faces.push(new THREE.Face3(f[j], f[(j + 1) % f.length], v_idx));
          new_f_to_old_f.push(i);
        }
      }
    }

    geometry.computeFaceNormals();

    var meshMaterial = new THREE.MeshLambertMaterial( {
      color: 0x0000ff,
      opacity: 1,
      transparent: true,
    } );

    var mesh = new THREE.Mesh( geometry, meshMaterial );
    mesh.material.side = THREE.FrontSide; // front faces
    mesh.renderOrder = 1;
    group.add( mesh );

    // edges
    for (var i = 0; i < polyhedron.edge.length; i++) {
      let e = polyhedron.edge[i];
      var edge = cylinderMesh(geometry.vertices[e[0]], geometry.vertices[e[1]], edgeMaterial);

      group.add(edge);

      var edge_faces = [];
      var normals = [];
      for (var j = 0; j < geometry.faces.length; j++) {
        let f = geometry.faces[j];

        // check if this face has this edge
        if ((f.a == e[0]) + (f.a == e[1]) + (f.b == e[0]) + (f.b == e[1]) + (f.c == e[0]) + (f.c == e[1]) == 2) {
          edge_faces.push(new_f_to_old_f[j]);
          normals.push(f.normal);
        }
      }
      var angle = Math.acos(normals[0].dot(normals[1])) * 180 / Math.PI;

      edges[edge.uuid] = {
        selected: false,
        index: i,
        angle: angle,
        edge_faces: edge_faces
      }
    }

  }

  // this code excerpt is taken from Lee Stemkoski
  // https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/Polyhedra.html
  function cylinderMesh(point1, point2, material) {
      var direction = new THREE.Vector3().subVectors(point2, point1);
      var arrow = new THREE.ArrowHelper(direction.clone().normalize(), point1);
      var rotation = new THREE.Euler().setFromQuaternion(arrow.quaternion);
      var edgeGeometry = new THREE.CylinderGeometry( 0.02, 0.02, direction.length(), 8, 4 );
      var edge = new THREE.Mesh(edgeGeometry, material);
      var position = new THREE.Vector3().addVectors(point1, direction.multiplyScalar(0.5));
      edge.position.set(position.x, position.y, position.z);
      edge.rotation.set(rotation.x, rotation.y, rotation.z);
      return edge;
  }

  function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

  }

  function onClick( event ) {
    //event.preventDefault();

    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

    raycaster.setFromCamera( mouse, camera );

    const intersects = raycaster.intersectObjects(group.children, true);
    if ( intersects.length > 0 ) {
      var uuid = intersects[0].object.uuid;
      if (uuid in edges) {
        console.log(intersects[0]);
        if (edges[uuid].selected) {
          intersects[0].object.material = edgeMaterial;
        } else {
          intersects[0].object.material = edgeMaterialSelected;
        }
        edges[uuid].selected = !edges[uuid].selected;
        intersects[0].object.material.needsUpdate = true;
      }

		}
  }

  function animate() {
    requestAnimationFrame( animate );

    //group.rotation.y += 0.003;

    render();
  }

  function render() {
    renderer.render( scene, camera );
  }

  </script>


  </body>
</html>
