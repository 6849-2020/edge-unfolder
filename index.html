<!DOCTYPE html>
<html lang="en">
  <head>
  <title>6.849 - EDGE UNFOLDER</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link rel="stylesheet" href="css/main.css">
  <script src="js/polyhedra.js"></script>
  </head>
  <body>

    <div id="info" style="font-size: 24px;">
      EDGE UNFOLDER
    </div>
    <a id="downloadAnchorElem" style="display:none"></a>


  <script type="module">

  import * as THREE from 'https://unpkg.com/three@0.121.1/build/three.module.js';

  import { GUI } from 'https://unpkg.com/three@0.121.1/examples/jsm/libs/dat.gui.module.js';

  import { OrbitControls } from 'https://unpkg.com/three@0.121.1/examples/jsm/controls/OrbitControls.js';

  var group, camera, scene, renderer, raycaster;

  var parameters = {
    exportToFold: function() {
      exportToFold();
    }
  };


  const mouse = new THREE.Vector2();
  var edgeMaterial = new THREE.MeshLambertMaterial( {
    color: 0xff0000
  } );
  var edgeMaterialSelected = new THREE.MeshLambertMaterial( {
    color: 0x00ff00
  } );

  var polyhedron;
  var edges = {};

  init();
  animate();

  function init() {

    scene = new THREE.Scene();

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    //renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    // camera

    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
    camera.position.set( 1, 2, 3 );
    scene.add( camera );

    // controls

    var controls = new OrbitControls( camera, renderer.domElement );
    controls.maxDistance = 500;
    //controls.maxPolarAngle = Math.PI / 2;

    scene.add( new THREE.AmbientLight( 0x222222 ) );

    // light

    var light = new THREE.PointLight( 0xffb7b7, 1 );
    light.position.set( 5, 5, 5 );
    camera.add( light );

    // Raycaster
    raycaster = new THREE.Raycaster();
		raycaster.params.Line.threshold = 0.1;

    group = new THREE.Group();
    scene.add( group );

    polyhedron = POLYHEDRA.J1;
    displayPolyhedron();

    // dat.GUI

    var gui = new GUI( { width: 500 } );

    // this code excerpt is taken from Lee Stemkoski
    // https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/Polyhedra.html
    var categoryFolders = {};
    for (var arg in POLYHEDRA) {
      var guiSection = gui;
      if ( POLYHEDRA[arg].hasOwnProperty("category") ) {
        var category = POLYHEDRA[arg].category[0];
        if ( !categoryFolders.hasOwnProperty(category) )
          categoryFolders[category] = gui.addFolder(category);
        guiSection = categoryFolders[category];
      }

      parameters[arg] = function() {};

      guiSection.add( parameters, arg )
        .name( POLYHEDRA[arg].name )
        .onChange( function(value) {
          polyhedron = POLYHEDRA[this.property];
          displayPolyhedron();
        });
    }

    gui.add(parameters, 'exportToFold').name("EXPORT TO FOLD");

    document.addEventListener( 'click', onClick, false );
    window.addEventListener( 'resize', onWindowResize, false );
  }

  function displayPolyhedron() {
    while (group.children.length > 0) {
      group.remove(group.children[0]);
    }
    edges = {};

    var geometry = new THREE.Geometry();
    for (var i = 0; i < polyhedron.vertex.length; i++) {
      geometry.vertices.push(new THREE.Vector3(polyhedron.vertex[i][0], polyhedron.vertex[i][1], polyhedron.vertex[i][2]));
    }

    for (var i = 0; i < polyhedron.face.length; i++) {
      var f = polyhedron.face[i];
      if (f.length == 3) {
        geometry.faces.push(new THREE.Face3(f[0], f[1], f[2]));
      } else {
        // do a simple triangulation
        // add a new vertex at the center
        var v = new THREE.Vector3(0, 0, 0);
        for (var j = 0; j < f.length; j++) {
          v.add(geometry.vertices[f[j]]);
        }
        v.divideScalar(f.length);
        var v_idx = geometry.vertices.length;
        geometry.vertices.push(v);

        for (var j = 0; j < f.length; j++) {
          geometry.faces.push(new THREE.Face3(f[j], f[(j + 1) % f.length], v_idx));
        }
      }
    }

    geometry.computeFaceNormals();

    var meshMaterial = new THREE.MeshLambertMaterial( {
      color: 0x0000ff,
      opacity: 1,
      transparent: true,
    } );

    var mesh = new THREE.Mesh( geometry, meshMaterial );
    mesh.material.side = THREE.FrontSide; // front faces
    mesh.renderOrder = 1;
    group.add( mesh );

    // edges
    for (var i = 0; i < polyhedron.edge.length; i++) {
      let e = polyhedron.edge[i];
      var edge = cylinderMesh(geometry.vertices[e[0]], geometry.vertices[e[1]], edgeMaterial);

      group.add(edge);

      var normals = [];
      for (var j = 0; j < geometry.faces.length; j++) {
        let f = geometry.faces[j];

        // check if this face has this edge
        if ((f.a == e[0]) + (f.a == e[1]) + (f.b == e[0]) + (f.b == e[1]) + (f.c == e[0]) + (f.c == e[1]) == 2) {
          normals.push(f.normal);
        }
      }
      var angle = Math.acos(normals[0].dot(normals[1])) * 180 / Math.PI;
      console.log(angle);

      edges[edge.uuid] = {
        selected: false,
        index: i,
        angle: angle
      }
    }

  }

  // this code excerpt is taken from Lee Stemkoski
  // https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/Polyhedra.html
  function cylinderMesh(point1, point2, material) {
      var direction = new THREE.Vector3().subVectors(point2, point1);
      var arrow = new THREE.ArrowHelper(direction.clone().normalize(), point1);
      var rotation = new THREE.Euler().setFromQuaternion(arrow.quaternion);
      var edgeGeometry = new THREE.CylinderGeometry( 0.02, 0.02, direction.length(), 8, 4 );
      var edge = new THREE.Mesh(edgeGeometry, material);
      var position = new THREE.Vector3().addVectors(point1, direction.multiplyScalar(0.5));
      edge.position.set(position.x, position.y, position.z);
      edge.rotation.set(rotation.x, rotation.y, rotation.z);
      return edge;
  }

  function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

  }

  function onClick( event ) {
    //event.preventDefault();

    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

    raycaster.setFromCamera( mouse, camera );

    const intersects = raycaster.intersectObjects(group.children, true);
    if ( intersects.length > 0 ) {
      var uuid = intersects[0].object.uuid;
      if (uuid in edges) {
        console.log(intersects[0]);
        if (edges[uuid].selected) {
          intersects[0].object.material = edgeMaterial;
        } else {
          intersects[0].object.material = edgeMaterialSelected;
        }
        edges[uuid].selected = !edges[uuid].selected;
        intersects[0].object.material.needsUpdate = true;
      }

		}
  }

  function animate() {
    requestAnimationFrame( animate );

    //group.rotation.y += 0.003;

    render();
  }

  function render() {
    renderer.render( scene, camera );
  }

  function exportToFold() {
    var edges_vertices = [];
    var edges_assignment = [];
    var edges_foldAngle = [];
    for (var uuid in edges) {
      var eIdx = edges[uuid].index;

      // TODO: if edge is selected - split it to two Boundary edges, and split the vertices, and change the faces...
      // if (edges[uuid].selected) {
      //
      // } else {
      //
      // }
      edges_vertices.push(polyhedron.edge[eIdx]);
      edges_assignment.push("M");
      edges_foldAngle.push(-edges[uuid].angle);
    }
    var fold = {
      file_spec : 1.1,
      file_creator : "EDGE UNFOLDER v0.1",
      file_classes : ["singleModel"],
      frame_classes: ["foldedForm"],
      frame_attributes: ["3D"],
      vertices_coords : polyhedron.vertex,
      faces_vertices : polyhedron.face,
      edges_vertices : edges_vertices,
      edges_assignment : edges_assignment,
      edges_foldAngle : edges_foldAngle
    }
    //https://stackoverflow.com/questions/19721439/download-json-object-as-a-file-from-browser
    var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(fold));
    var dlAnchorElem = document.getElementById('downloadAnchorElem');
    dlAnchorElem.setAttribute("href",     dataStr     );
    dlAnchorElem.setAttribute("download", "edge-unfolder.fold");
    dlAnchorElem.click();
  }

  </script>


  </body>
</html>
