<!DOCTYPE html>
<html lang="en">
  <head>
  <title>6.849 - EDGE UNFOLDER</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link href="dependencies/bootstrap.min.css" rel="stylesheet" type="text/css"/>
  <link rel="stylesheet" type="text/css" href="dependencies/flat-ui.min.css"/>
  <link rel="stylesheet" type="text/css" href="dependencies/jquery-ui.min.css"/>
  <link rel="stylesheet" type="text/css" href="css/nav.css"/>
  <link rel="stylesheet" type="text/css" href="css/main.css"/>

  <script type="text/javascript" src="dependencies/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="dependencies/jquery-ui.min.js"></script>
  <script type="text/javascript" src="dependencies/flat-ui.min.js"></script>

  <script src="js/polyhedra.js"></script>
  <script src="js/disjoint-set.js"></script>
  <script src="js/loadOBJ.js"></script>
  <script src="js/export.js"></script>

  <script type="text/javascript" src="js/paper-full.min.js"></script>
  <script type="text/javascript" src="js/SVGExport.js"></script>

  </head>
  <body>

    <div class="modal fade" id="aboutModal" tabindex="-1" role="dialog">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-body">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                      <span aria-hidden="true">&times;</span>
                    </button>
                    <p>
                    <b>EDGE UNFOLDER</b><br/>
                        This app allows you to play around with edge cutting and unfolding of polyhedra and other 3D objects.
                    </p>
                </div>
            </div><!-- /.modal-content -->
        </div><!-- /.modal-dialog -->
    </div><!-- /.modal -->

    <nav id="globalNav" class="navbar navbar-inverse navbar-embossed" role="navigation">
        <div class="collapse navbar-collapse" id="navbar-collapse-01">
            <ul class="nav navbar-nav navbar-left">
                <li class="dropdown navDropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Import <b class="caret"></b></a>
                    <span class="dropdown-arrow"></span>
                    <ul class="dropdown-menu" id="import_menu"  style="min-width: 200px;">
                      <li><a id="loadOBJ" href="#">Import OBJ</a></li>
                      <li class="divider"></li>
                    </ul>
                </li>
                <li class="dropdown navDropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Export <b class="caret"></b></a>
                    <span class="dropdown-arrow"></span>
                    <ul class="dropdown-menu" style="min-width: 200px;">
                      <li><a id="exportOrigamiSimulator" href="#">Export to Origami Simulator</a></li>
                      <li><a id="exportFold" href="#">Export to FOLD</a></li>
                    </ul>
                </li>
                <li><a id="pattern" class="menuHoverControls" target="_blank" href="#">Pattern</a></li>
                <li><a id="about" class="menuHoverControls" target="_blank" href="#">About</a></li>
            </ul>
        </div><!-- /.navbar-collapse -->

    </nav>

    <div  id="threeContainer"></div>

    <div id="topright">
        <div id="polyhedronName"></div>
    </div>

    <div id="controlsBottom">
      <div id="controlsToggle" class="bigToggle">
          <div>
              <a href="#" id="liveToggle"><div><img class="preserveAspect" src="assets/liveBox.png"/><span>Live</span></div></a><div class="separator"></div><a href="#" id="staticToggle"><div class="active"><img class="preserveAspect" src="assets/staticBox.png"/><span>Static</span></div></a>
          </div>
          View Mode
      </div>
        <a href="#" id="resetBottom" class="btn btn-lg btn-default">Reset</a>
        <a href="#" id="testBottom" class="btn btn-lg btn-default">Cut Assignment</a>
        <a href="#" id="SVGBottom" style="display:unset
" class="btn btn-lg btn-default">SVG Export</a>
    </div>

    <a id="downloadAnchorElem" style="display:none"></a>
    <!-- get user input OBJ file -->
    <input id="myInput" type="file" style="display:none" />
    <!-- hidden canvas for svg export -->
    <canvas id="canvasSVG" width="500" height="500" style="display: none"></canvas>


  <script type="module">

  import * as THREE from 'https://unpkg.com/three@0.121.1/build/three.module.js';

  import { OrbitControls } from 'https://unpkg.com/three@0.121.1/examples/jsm/controls/OrbitControls.js';
  import { TrackballControls } from 'https://unpkg.com/three@0.121.1/examples/jsm/controls/TrackballControls.js';

  var group, camera, scene, renderer, raycaster, controls;

  var polyhedron;
  var edges = {};
  var faces = {};

  var selection = [];
  var remaining_Faces=[];
  var remaining_Faces_count = 0;

  let fileUpload = document.getElementById("myInput")

  var liveUnfoldMode = false

  const mouse = new THREE.Vector2();
  var edgeMaterial = new THREE.MeshLambertMaterial( {
    color: 0x000000
  } );
  var edgeMaterialSelected = new THREE.MeshLambertMaterial( {
    color: 0x40E0D0
  } );
  var edgeMaterialFixed = new THREE.MeshLambertMaterial( {
      color: 0xff9900 //0x838383
  } );

  var polygonOffset = 0.5
  var material, material2, material3
  material = new THREE.MeshPhongMaterial({
      flatShading:true,
      side:THREE.FrontSide,
      polygonOffset: true,
      polygonOffsetFactor: polygonOffset, // positive value pushes polygon further away
      polygonOffsetUnits: 1,
      wireframe: false,
  });
  material2 = new THREE.MeshPhongMaterial({
      flatShading:true,
      side:THREE.BackSide,
      polygonOffset: true,
      polygonOffsetFactor: polygonOffset, // positive value pushes polygon further away
      polygonOffsetUnits: 1,
      wireframe: false,
  });
  material3 = new THREE.MeshPhongMaterial({
      wireframe: true,
  });
  material.color.setStyle( "#ec008b");
  material2.color.setStyle( "#dddddd");
  material3.color.setStyle( "#000000");

  //backside.visible = true;


  init();
  initControls();
  animate();

  function init() {

    var container = document.getElementById("threeContainer");
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    container.append( renderer.domElement );

    // camera
    camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 500 );
    camera.position.set( 0, -1.6, -4 );
    scene.add( camera );

    // controls

    controls = new TrackballControls(camera, renderer.domElement);
    controls.rotateSpeed = 7.0;
    controls.zoomSpeed = 7;
    controls.noPan = true;
    controls.staticMoving = true;
    controls.dynamicDampingFactor = 0.3;
    controls.minDistance = 1;
    controls.maxDistance = 30;

    // light
    var directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight1.position.set(0, 40, 0);
    scene.add(directionalLight1);
    var directionalLight4 = new THREE.DirectionalLight(0xffffff, 0.3);
    directionalLight4.position.set(0, -40, 0);
    scene.add(directionalLight4);
    var directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight2.position.set(40, -12, 0);
    scene.add(directionalLight2);
    var directionalLight3 = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight3.position.set(-40, -12, 0);
    scene.add(directionalLight3);
    var directionalLight4 = new THREE.DirectionalLight(0xffffff, 0.3);
    directionalLight4.position.set(0, 12, 40);
    scene.add(directionalLight4);
    var directionalLight5 = new THREE.DirectionalLight(0xffffff, 0.3);
    directionalLight5.position.set(0, 12 , -40);
    scene.add(directionalLight5);

    // Raycaster
    raycaster = new THREE.Raycaster();
    raycaster.params.Line.threshold = 0.1;

    group = new THREE.Group();
    scene.add( group );

    polyhedron = POLYHEDRA.Icosahedron;
    displayPolyhedron();

    document.addEventListener( 'click', onClick, false );
    document.addEventListener( 'mousemove', onMouseMove, false );
    window.addEventListener( 'resize', onWindowResize, false );
  }

  function initControls() {
    setLink("#about", function(){
        $('#aboutModal').modal('show');
    });

    setLink("#exportOrigamiSimulator", function(){
        simulate(polyhedron, edges);
    });

    setLink("#exportFold", function() {
      let fold = exportToFold(polyhedron, edges);
      //https://stackoverflow.com/questions/19721439/download-json-object-as-a-file-from-browser
      var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(fold));
      var dlAnchorElem = document.getElementById('downloadAnchorElem');
      dlAnchorElem.setAttribute("href",     dataStr     );
      dlAnchorElem.setAttribute("download", "edge-unfolder.fold");
      dlAnchorElem.click();
    });

    setLink("#loadOBJ", function() {
      fileUpload.click();
      fileUpload.onchange = function(){
        async function asyncCall() {
          await loadOBJ();
          await computeOBJ()
          polyhedron = userOBJ;
          displayPolyhedron();
        }
        asyncCall();
        selection = []
      }
    });

    setLink("#resetBottom", function() {
      selection = []
      displayPolyhedron();
    });

    setLink("#testBottom", function() {
        var faceCount = 0
        var edgeList = [];
        for(var i in faces){
            faceCount += 1
        }
        for(var i in edges){
            edgeList.push(edges[i].index)
        }

        var faceQueue = [0]
        var faceGraph = []
        var faceTraverse = [0]
        var edgesToCut = []


        while(faceCount > 1) {

            //var f_index = faceTraverse.shift()
            var f_index = faceTraverse.pop()
            var f = faces[f_index]

            if (f.grouped) {

                var tempGroup = []
                var tempNextFaces = []
                var tempNextEdges = []
                tempGroup.push(...f.group)

                for (var i = 0; i < tempGroup.length; i++) {
                    for (var j = 0; j < 3; j++) {
                        if (!faces[tempGroup[i]].face_edges_dummy[j]) {
                            tempNextFaces.push(faces[tempGroup[i]].face_nextFace[j])
                            tempNextEdges.push(faces[tempGroup[i]].face_edges[j])
                        }
                    }
                }

                tempGroup = tempGroup.filter(n => !faceQueue.includes(n))
                for (var i = 0; i<tempGroup.length; i++) {
                    faceQueue.push(tempGroup[i])
                    faceCount -= 1
                }

                for (var i = 0; i < tempNextFaces.length; i++) {

                    if (!faceQueue.includes(tempNextFaces[i])) {

                        if(faces[tempNextFaces[i]].grouped){
                            for (var j = 0; j<faces[tempNextFaces[i]].group.length;j++){

                                if(!faceQueue.includes(faces[tempNextFaces[i]].group[j])){
                                    faceQueue.push(faces[tempNextFaces[i]].group[j])
                                    faceCount -= 1
                                }
                            }
                            faceTraverse.push(tempNextFaces[i])
                            faceGraph.push(tempNextEdges[i])

                        }else{

                            faceTraverse.push(tempNextFaces[i])
                            faceQueue.push(tempNextFaces[i])
                            faceGraph.push(tempNextEdges[i])
                            faceCount -= 1
                        }
                    }

                }

            }
            else {

                for (var i = 0; i < 3; i++) {

                    if (!faceQueue.includes(f.face_nextFace[i])) {

                        if(faces[f.face_nextFace[i]].grouped){

                            for (var j = 0; j<faces[f.face_nextFace[i]].group.length;j++){
                                if(!faceQueue.includes(faces[f.face_nextFace[i]].group[j])){
                                    faceQueue.push(faces[f.face_nextFace[i]].group[j])
                                    faceCount -= 1
                                }
                            }
                            faceTraverse.push(f.face_nextFace[i])
                            faceGraph.push(f.face_edges[i])

                        }else{

                            faceTraverse.push(f.face_nextFace[i])
                            faceQueue.push(f.face_nextFace[i])
                            faceGraph.push(f.face_edges[i])
                            faceCount -= 1

                        }
                    }
                }

            }

        }



        selection = edgeList.filter(n=> !faceGraph.includes(n))
        recomputeEdgeUnfolding(selection)


    });
    setLink("#SVGBottom", function() {

        var zVector = new THREE.Vector3(0,0,1);
        var faceNormal = group.getObjectByName("face_0").geometry.faces[0].normal;
        var cp = (zVector.cross(faceNormal)).normalize()
        var dp = (new THREE.Vector3(0,0,1)).dot(faceNormal)
        var theta = Math.PI - Math.acos(dp);

        group.matrixWorldNeedsUpdate = false
        group.position.applyAxisAngle(cp,theta);
        group.rotateOnWorldAxis(cp,theta);
        group.updateMatrixWorld()


        var boundaryEdges = []
        var creaseEdgesM = []
        var creaseEdgesV = []

        for (var face in faces){

            var array = faces[face].position
            var vector0 = new THREE.Vector3(array[0],array[1],array[2])
            var vector1 = new THREE.Vector3(array[3],array[4],array[5])
            var vector2 = new THREE.Vector3(array[6],array[7],array[8])

            vector0.applyMatrix4( group.matrixWorld );
            vector1.applyMatrix4( group.matrixWorld );
            vector2.applyMatrix4( group.matrixWorld );

            var vecter = [vector0,vector1,vector2]

            //face_edges_dummy
            //edges_selected
            for( var i = 0 ; i < 3 ; i++){

                if(!faces[face].face_edges_dummy[i]) {

                    var edgeIndex = faces[face].face_edges[i]
                    var selected
                    var convex
                    for (var edge in edges){
                        if(edges[edge].index == edgeIndex) {
                            selected = edges[edge].selected
                            convex = edges[edge].convex
                        }
                    }

                    if (!selected) {// crease edges

                        if(convex) creaseEdgesM.push([vecter[i % 3].x, vecter[i % 3].y, vecter[(i + 1) % 3].x, vecter[(i + 1) % 3].y])
                        else creaseEdgesV.push([vecter[i % 3].x, vecter[i % 3].y, vecter[(i + 1) % 3].x, vecter[(i + 1) % 3].y])

                    } else {// boundary edges
                        boundaryEdges.push([vecter[i % 3].x, vecter[i % 3].y, vecter[(i + 1) % 3].x, vecter[(i + 1) % 3].y])

                    }
                }
            }
        }


        group.position.applyAxisAngle(cp,-theta);
        group.rotateOnWorldAxis(cp,-theta);
        group.updateMatrixWorld()

        drawSVG(boundaryEdges,creaseEdgesM,creaseEdgesV)

        var fileName = polyhedron.name + ".svg"
        var url = "data:image/svg+xml;utf8," + encodeURIComponent(paper.project.exportSVG({asString:true}));
        var link = document.createElement("a");
        link.download = fileName;
        link.href = url;
        link.click();

    });



    function controlMode(val){
        if (val == "static") {
            $("#staticToggle>div").addClass("active");
            $("#liveToggle>div").removeClass("active");
            for (var i in group.children){
                if(group.children[i].name.charAt(0)=="f") group.children[i].visible = false
                if(group.children[i].name=="dummy") group.children[i].visible = true
            }
            liveUnfoldMode = false
            // Change to STATIC mode
        } else {
            $("#staticToggle>div").removeClass("active");
            $("#liveToggle>div").addClass("active");
            for (var i in group.children){
                if(group.children[i].name.charAt(0)=="f") group.children[i].visible = true
                if(group.children[i].name=="dummy") group.children[i].visible = false
            }
            liveUnfoldMode = true
            // Change to LIVE mode
        }
    }
    setLink("#staticToggle", function(){
        controlMode("static");
    });
    setLink("#liveToggle", function(){
        controlMode("live");
    });

    var categoryFolders = {};
    var categoryKey = 0;
    for (var arg in POLYHEDRA) {
      if ( POLYHEDRA[arg].hasOwnProperty("category") ) {
        var category = POLYHEDRA[arg].category[0];
        if ( !categoryFolders.hasOwnProperty(category) ) {
            $("#import_menu").append(`<li class="dropdown-submenu">
              <a tabindex="-1">` + category + `<span class="pull-right fui-arrow-right"></span></a>
              <ul class="dropdown-menu" id="category_` + categoryKey + `"></ul>
              </li>`);
            categoryFolders[category] = categoryKey;
            categoryKey++;
        }

        var currentCategory = categoryFolders[category];

        $("#category_" + currentCategory).append(`<li>
          <a href="#" class="polyhedra" data-url="`+arg+`">` + POLYHEDRA[arg].name + `</a>
          </li>`)
      }
    }

    setLink(".polyhedra", function(e){
        var arg = $(e.target).data("url");
        if (arg) {
          polyhedron = POLYHEDRA[arg];
          selection = []
          displayPolyhedron();
        }
    });


  }

  async function displayPolyhedron() {

    var link = document.getElementById('SVGBottom');
    link.style.display = 'unset';


    document.getElementById("polyhedronName").innerHTML = polyhedron.name;

    while (group.children.length > 0) {
      group.remove(group.children[0]);
    }
    edges = {};
    faces = {};
    remaining_Faces = []
    var face_count = 0;

    var geometry = new THREE.Geometry();
    var geometry_dummy = new THREE.Geometry();

    for (var i = 0; i < polyhedron.vertex.length; i++) {
      geometry.vertices.push(new THREE.Vector3(polyhedron.vertex[i][0], polyhedron.vertex[i][1], polyhedron.vertex[i][2]));
      geometry_dummy.vertices.push(new THREE.Vector3(polyhedron.vertex[i][0], polyhedron.vertex[i][1], polyhedron.vertex[i][2]));
    }

    var new_f_to_old_f = [];
    var face_divided = []; // store divided faces e.g) 4 triangulated rectangle
    for (var i = 0; i < polyhedron.face.length; i++) {
      var f = polyhedron.face[i];
      if (f.length == 3) { // face is triangle
        geometry.faces.push(new THREE.Face3(f[0], f[1], f[2]));
        geometry_dummy.faces.push(new THREE.Face3(f[0], f[1], f[2]));
        new_f_to_old_f.push(i);

        faces[face_count] = {
          folded: true,
          grouped: false,
          group: [],
          index: face_count,
          face_vertices: [f[0], f[1], f[2]],
          face_edges: [null,null,null], // 0 is place holder for now
          face_edges_linked: [true,true,true],
          face_edges_flattened: [false,false,false],
          face_edges_dummy: [false,false,false],
          face_edges_angle:[0,0,0], // 0 is place holder for now
          face_nextFace: [null,null,null],
          name:'face_' + face_count,
          position: [polyhedron.vertex[f[0]][0],polyhedron.vertex[f[0]][1],polyhedron.vertex[f[0]][2],polyhedron.vertex[f[1]][0],polyhedron.vertex[f[1]][1],polyhedron.vertex[f[1]][2],polyhedron.vertex[f[2]][0],polyhedron.vertex[f[2]][1],polyhedron.vertex[f[2]][2]]
        }
        face_count +=1
        remaining_Faces.push(i)
        remaining_Faces_count += 1

        // add face dictionary
      } else { // face !triangle
        // do a simple triangulation
        // add a new vertex at the center
        var v = new THREE.Vector3(0, 0, 0);
        for (var j = 0; j < f.length; j++) {
          v.add(geometry.vertices[f[j]]);
        }
        v.divideScalar(f.length);
        var v_idx = geometry.vertices.length;
        geometry.vertices.push(v);
        geometry_dummy.vertices.push(v);

        var face_divided_temp = [] // temporary array to store grouped faces
        for (var j = 0; j < f.length; j++) {
            face_divided_temp.push(face_count+j)
        }
        for (var j = 0; j < f.length; j++) {
          geometry.faces.push(new THREE.Face3(f[j], f[(j + 1) % f.length], v_idx));
          geometry_dummy.faces.push(new THREE.Face3(f[j], f[(j + 1) % f.length], v_idx));
          new_f_to_old_f.push(i);

          faces[face_count] = {
              folded: true,
              grouped: true,
              group: face_divided_temp,
              index: face_count,
              face_vertices: [f[j], f[(j + 1) % f.length], v_idx],
              face_edges: [null,null,null], // 0 is place holder for now
              face_edges_linked: [true,true,true],
              face_edges_flattened: [false,true,true],
              face_edges_dummy: [false,true,true],
              face_edges_angle:[0,0,0], // 0 is place holder for now
              face_nextFace: [null,face_divided_temp[(j+1)%(face_divided_temp.length)],face_divided_temp[((j-1)+face_divided_temp.length)%face_divided_temp.length]],
              name:'face_' + face_count,
              position: [polyhedron.vertex[f[j]][0],polyhedron.vertex[f[j]][1],polyhedron.vertex[f[j]][2],polyhedron.vertex[f[(j + 1) % f.length]][0],polyhedron.vertex[f[(j + 1) % f.length]][1],polyhedron.vertex[f[(j + 1) % f.length]][2],geometry.vertices[v_idx][0],geometry.vertices[v_idx][1],geometry.vertices[v_idx][2]]
            }
            face_count +=1
            remaining_Faces.push(i)
            remaining_Faces_count += 1
        }
        face_divided.push(face_divided_temp)
      }
    }

    geometry.computeFaceNormals();
    geometry_dummy.computeFaceNormals();

    var mesh = new THREE.Mesh( geometry, material );
    mesh.material.side = THREE.FrontSide; // front faces
    mesh.renderOrder = 1;
    group.add( mesh );

    var mesh = new THREE.Mesh( geometry_dummy, material );
    mesh.material.side = THREE.FrontSide; // front faces
    mesh.renderOrder = 1;
    mesh.name = 'dummy';

    if(liveUnfoldMode) mesh.visible = false


    group.add( mesh );


    // this is reduendent step to remove original mesh and create new meshs, but each triangle is one object
    v = group.children[0].geometry.vertices
    for (var i = 0; i < group.children[0].geometry.faces.length; i++) {
        var geometry = new THREE.Geometry();
        f = group.children[0].geometry.faces[i]
        // add vertices
        geometry.vertices.push(v[f.a]);
        geometry.vertices.push(v[f.b]);
        geometry.vertices.push(v[f.c]);

        // add faces ( we are only dealing with triangles
        geometry.faces.push(new THREE.Face3(0, 1, 2));
        geometry.faces.push(new THREE.Face3(0, 1, 2))

        geometry.faces[0].materialIndex = 0
        geometry.faces[1].materialIndex = 1

        // create mesh and add it to group
        geometry.computeFaceNormals();
        var mesh = new THREE.Mesh( geometry, [material,material2] );
        mesh.name = 'face_' + i
        mesh.index = i
        if(!liveUnfoldMode) mesh.visible = false

        group.add( mesh );

        // assigning two colors in mesh by duplicating face
        //https://stackoverflow.com/questions/48177470/adding-a-different-colour-to-each-side-of-this-obj

    }

    // edges
    for (var i = 0; i < polyhedron.edge.length; i++) {
      let e = polyhedron.edge[i];

      geometry = group.children[0].geometry // This line added
      var edge = cylinderMesh(geometry.vertices[e[0]], geometry.vertices[e[1]], edgeMaterial);
      edge.name = 'edge_' + i
      //edge.index = i

      group.add(edge);

      var edge_faces = [];
      var edge_faces_old = [];// this is needed for storing number of triangulated faces
      var normals = [];
      var vertexVector = [];
      var planeVector = [];
      for (var j = 0; j < geometry.faces.length; j++) {
        let f = geometry.faces[j];

        // check if this face has this edge
        if ((f.a == e[0]) + (f.a == e[1]) + (f.b == e[0]) + (f.b == e[1]) + (f.c == e[0]) + (f.c == e[1]) == 2) {
          edge_faces.push(new_f_to_old_f[j]);
          edge_faces_old.push(j);
          normals.push(f.normal);

          if ( (f.a == e[0]) + (f.a == e[1]) +  (f.b == e[0]) + (f.b == e[1]) == 2){
              faces[j].face_edges[0] =i
              vertexVector.push((geometry.vertices[f.c].clone()).sub((geometry.vertices[f.a].clone().add(geometry.vertices[f.b].clone())).multiplyScalar(0.5)))
              planeVector.push( (geometry.vertices[f.a].clone().sub(geometry.vertices[f.b].clone())).cross((geometry.vertices[f.a].clone().sub(geometry.vertices[f.c].clone()))))

          }
          else if( (f.b == e[0]) + (f.b == e[1]) +  (f.c == e[0]) + (f.c == e[1]) == 2 ){
              faces[j].face_edges[1] =i
              vertexVector.push((geometry.vertices[f.a].clone()).sub((geometry.vertices[f.b].clone().add(geometry.vertices[f.c].clone())).multiplyScalar(0.5)))
              planeVector.push( (geometry.vertices[f.b].clone().sub(geometry.vertices[f.c].clone())).cross((geometry.vertices[f.b].clone().sub(geometry.vertices[f.a].clone()))))
          }
          else{
              faces[j].face_edges[2] =i
              vertexVector.push((geometry.vertices[f.b].clone()).sub((geometry.vertices[f.c].clone().add(geometry.vertices[f.a].clone())).multiplyScalar(0.5)))
              planeVector.push( (geometry.vertices[f.c].clone().sub(geometry.vertices[f.a].clone())).cross((geometry.vertices[f.c].clone().sub(geometry.vertices[f.b].clone()))))
          }
        }
      }

      var convex ;
      var mv =  vertexVector[1].dot(planeVector[0])
      if(mv>0) convex = false;
      else convex = true;

      let dp = normals[0].dot(normals[1]);

      var angle;
      if(convex){angle = 180 - (Math.acos(dp) * 180 / Math.PI);}
      else{ angle =  (Math.acos(dp) * 180 / Math.PI) - 180;}
      //https://stackoverflow.com/questions/10612829/tetrahedron-orientation-for-triangle-meshes

      edges[edge.uuid] = {
        selected: false,
        hover: false,
        index: i,
        angle: angle,
        convex: convex,
        edge_faces: edge_faces,
        flattened: false, // added
        edge_vertices: e, // added
        edge_faces_old: edge_faces_old, // added
      }
    }
    // add adjacent face list in faces by iterating edges
    for (var edge in edges) {
      var linked = edges[edge].edge_faces_old
      //var linked = edges[edge].edge_faces
      for ( var i =0; i<2; i++){ // assume that edge have two adjacent faces
        var index = faces[linked[i]].face_edges.indexOf(edges[edge].index)
        faces[linked[i]].face_nextFace[index] = linked[(i+1)%2]
        faces[linked[i]].face_edges_angle[index] = edges[edge].angle
      }
    }
    group.remove(group.children[0]);

    return 1;

  }

  // this code excerpt is taken from Lee Stemkoski
  // https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/Polyhedra.html
  function cylinderMesh(point1, point2, material) {
      var direction = new THREE.Vector3().subVectors(point2, point1);
      var arrow = new THREE.ArrowHelper(direction.clone().normalize(), point1);
      var rotation = new THREE.Euler().setFromQuaternion(arrow.quaternion);
      var edgeGeometry = new THREE.CylinderGeometry( 0.01, 0.01, direction.length(), 8, 4 );
      var edge = new THREE.Mesh(edgeGeometry, material);
      var position = new THREE.Vector3().addVectors(point1, direction.multiplyScalar(0.5));
      edge.position.set(position.x, position.y, position.z);
      edge.rotation.set(rotation.x, rotation.y, rotation.z);
      return edge;
  }

  function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

    controls.handleResize();

  }

  function onClick( event ) {

    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

    raycaster.setFromCamera( mouse, camera );

    const intersects = raycaster.intersectObjects(group.children, true);
    if ( intersects.length > 0 ) {
      var uuid = intersects[0].object.uuid;

      if (uuid in edges) {


        if(edges[uuid].selected){
            selection.splice(selection.indexOf(parseInt(intersects[0].object.name.split("_")[1])),1)
            intersects[0].object.material = edgeMaterial;
        }else{
            selection.push(parseInt(intersects[0].object.name.split("_")[1]))
            intersects[0].object.material = edgeMaterialSelected;
        }
        edges[uuid].selected = !edges[uuid].selected;
        intersects[0].object.material.needsUpdate = true;

        recomputeEdgeUnfolding(selection)

      }

    }
  }

  function onMouseMove(event) {
    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

    raycaster.setFromCamera( mouse, camera );

    document.body.style.cursor = "default";

    const intersects = raycaster.intersectObjects(group.children, true);
    if ( intersects.length > 0 ) {
      var uuid = intersects[0].object.uuid;
      if (uuid in edges) {
        document.body.style.cursor = "pointer";
      }
		}
  }

  function animate() {
    requestAnimationFrame( animate );
    render();
  }

  function render() {
    controls.update();
    renderer.render( scene, camera );
  }

  function setLink(id, callback){
      $(id).click(function(e){
          e.preventDefault();
          callback(e);
      });
  }

  async function liveUnfold(faces,edges,edge_object,edge_clicked){

      var face_to_update =[]
      face_to_update.push(edge_clicked.edge_faces_old[0])
      face_to_update.push(edge_clicked.edge_faces_old[1])

      var edge_index  = edge_clicked.index

      var unfold_Not_Cut = false

      while(face_to_update.length>0){ // let's iterate faces.

          var f_index = face_to_update.pop()

          if(!unfold_Not_Cut){
              var face_edge_update_index = faces[f_index].face_edges.indexOf(edge_index) // unfold booleans
              faces[f_index].face_edges_linked[face_edge_update_index] = !faces[f_index].face_edges_linked[face_edge_update_index] // update booleans
          }

          var faceGroup = checkFaceGroup(faces, f_index)[0];
          var left_edges = checkFaceGroup(faces, f_index)[2];
          var face_Hinge_Index = checkFaceGroup(faces, f_index)[3];
          var face_Hinge_Edge_Index = checkFaceGroup(faces, f_index)[4];

          if(remaining_Faces.length == 1) {
              var link = document.getElementById('SVGBottom');
              link.style.display = 'unset';

              break;
          }

          if(!faces[f_index].face_edges_linked[face_edge_update_index] || (unfold_Not_Cut) ){

              unfold_Not_Cut = false
              // case 1 linked -> unlinked
              // case 1.1 just update
              if(left_edges == 0){ // trim face from others --> cut the piece from other faces.
                  //console.log("you just made an island")
              }
              else if(left_edges == 1){ // should be unfold using left single edge.
                  // Series Rotation
                  await series_Face_Rotation( group, faces, faceGroup, face_Hinge_Edge_Index )
                  // remove unfolded faces
                  remaining_Faces = remaining_Faces.filter(n=> !faceGroup.includes(n))

                  var f = faces[face_Hinge_Index]
                  for (var edge in edges){
                      if (edges[edge].index == f.face_edges[face_Hinge_Edge_Index]){
                          edges[edge].flattened = true
                      }
                  }
                  // change fixed edge color
                  var edge_toFix_index = f.face_edges[face_Hinge_Edge_Index]
                  var edge_object_toFix = scene.getObjectByName( "edge_" + edge_toFix_index);
                  edge_object_toFix.material = edgeMaterialFixed;

                  f.folded == false
                  f.face_edges_flattened[face_Hinge_Edge_Index] = true

                  var f_next = f.face_nextFace[face_Hinge_Edge_Index] // face to update( number)
                  faces[f_next].face_edges_flattened[faces[f_next].face_edges.indexOf(edge_toFix_index)] = true

                  if(left_edges = checkFaceGroup(faces, f_next)[2] == 1){
                      unfold_Not_Cut = true
                      face_to_update.push(f_next)
                  }
              }
              else{ // nothing happen.

              }
              // case 1.2 unfold
          }
          else{
              // case 2 unlinked -> linked
              // case 2.1 just update
              // case 2.2 refold

              break;
          }
      }
      return 1

  }

  async function rotateFace( group,faces, face, edge_vector_0, edge_vector_1 , angle ){

      // face : face object
      // edge_vector_0 : Starting Vector of rotating axis in 3D space
      // edge_vector_0 : Ending Vector of rotating axis in 3D space
      // rotation angle

      var vector0 = new THREE.Vector3(face.geometry.vertices[0].x,face.geometry.vertices[0].y,face.geometry.vertices[0].z)
      var vector1 = new THREE.Vector3(face.geometry.vertices[1].x,face.geometry.vertices[1].y,face.geometry.vertices[1].z)
      var vector2 = new THREE.Vector3(face.geometry.vertices[2].x,face.geometry.vertices[2].y,face.geometry.vertices[2].z)

      var axisVector = edge_vector_1.sub(edge_vector_0).normalize()
      var theta = Math.PI - angle/ 180 * Math.PI;

      face.geometry.matrixWorldNeedsUpdate = false

      face.position.sub( edge_vector_0 )
      face.position.applyAxisAngle(axisVector,theta);
      face.rotateOnWorldAxis(axisVector, theta);
      face.position.add( edge_vector_0 );

      face.updateMatrixWorld();

      vector0.applyMatrix4( face.matrixWorld );
      vector1.applyMatrix4( face.matrixWorld );
      vector2.applyMatrix4( face.matrixWorld );
      face.geometry.vertices[0] = vector0
      face.geometry.vertices[1] = vector1
      face.geometry.vertices[2] = vector2

      // add latest position
      faces[face.index].position = [vector0.x,vector0.y,vector0.z,vector1.x,vector1.y,vector1.z,vector2.x,vector2.y,vector2.z]

      // REMOVE SELECTED FACE and RECREATE NEW FACE,
      // FACE NAME and INDEX SHOULD BE SAME
      var geometry = new THREE.Geometry();
      geometry.vertices.push(vector0);
      geometry.vertices.push(vector1);
      geometry.vertices.push(vector2);
      geometry.faces.push(new THREE.Face3(0, 1, 2))
      geometry.faces.push(new THREE.Face3(0, 1, 2))

      if(!faces[face.index].grouped) geometry.faces.push(new THREE.Face3(0, 1, 2))
      else geometry.faces.push(new THREE.Face3(0, 1, 1))

      geometry.faces.push(new THREE.Face3(0, 1, 1))
      geometry.faces[0].materialIndex = 0
      geometry.faces[1].materialIndex = 1
      geometry.faces[2].materialIndex = 2
      geometry.computeFaceNormals();


      //var meshMaterial = new THREE.MeshLambertMaterial( { color: 0x0000ff, opacity: 1, transparent: true, } );
      var mesh = new THREE.Mesh( geometry, [material,material2,material3]);
      mesh.name = face.name
      mesh.index = face.index
      if(!liveUnfoldMode) mesh.visible = false
      else mesh.visible = true

      var toRemove;
      for (var i = 0 ; i<group.children.length ; i++){
          if (group.children[i].name == face.name){
              toRemove = i
              break;
          }
      }
      group.remove(group.children[toRemove])

      group.add( mesh );

      return 1;
  }

  async function series_Face_Rotation(group, faces, face_to_Rotate, edge_to_fold_index){

      // find specific face
      var face_object // a face to rotate
      var array = []

      async function asyncCall(){
          for (var i = 0; i < group.children.length; i++){
              if(group.children[i].index == faces[face_to_Rotate[0]].index) {
                  face_object = group.children[i]
                  array.push(...faces[face_to_Rotate[0]].position)
                  break;
              }
          }
          return 1
      }
      await asyncCall()

      var face_to_Rotate_Selected =[];

      for (var k = 0; k < face_to_Rotate.length; k++ ){

          faces[face_to_Rotate[k]].folded == false

          for (var l = 0; l < group.children.length; l++){
              if(group.children[l].index == face_to_Rotate[k]) {
                  face_to_Rotate_Selected.push(group.children[l])
              }
          }
      }

      for (var k = 0; k < face_to_Rotate.length; k++ ){
          const edge_vector_0 = new THREE.Vector3(parseFloat(array[edge_to_fold_index*3+0]),parseFloat(array[edge_to_fold_index*3+1]),parseFloat(array[edge_to_fold_index*3+2]))
          const edge_vector_1 = new THREE.Vector3(parseFloat(array[((edge_to_fold_index+1)%3)*3+0]),parseFloat(array[((edge_to_fold_index+1)%3)*3+1]),parseFloat(array[((edge_to_fold_index+1)%3)*3+2]))
          await rotateFace( group, faces, face_to_Rotate_Selected[k], edge_vector_0, edge_vector_1, faces[face_to_Rotate[0]].face_edges_angle[edge_to_fold_index])
      }

      return 1


  }

  function checkFaceGroup(faces, face_to_update) {

      var boundary_Edge = 0; // temporary 0 value
      var f = faces[face_to_update]
      var fSingle = []
      var fGroup = []
      var f_hinge = []
      var f_hinge_edge = []

      if (f.grouped) fSingle.push(...f.group);
      else fSingle.push(face_to_update)

      fGroup.push(...fSingle)

      while(fSingle.length>0){
          var face_visit = fSingle.pop()

          for ( var i = 0 ; i < 3 ; i++){
              if( (faces[face_visit].face_edges_linked[i] == true) && (faces[face_visit].face_edges_flattened[i] == true)){
                  if (!fGroup.includes(faces[face_visit].face_nextFace[i])){
                      if (!fSingle.includes(faces[face_visit].face_nextFace[i])){
                          fGroup.push(faces[face_visit].face_nextFace[i])
                          fSingle.push(faces[face_visit].face_nextFace[i])
                      }
                  }
              }
          }
      }


      var left_edges = 0;
      for (var l = 0; l < fGroup.length; l++) {
          boundary_Edge += (3 - faces[l].face_edges_dummy.reduce((a, b) => a + b))
          for (var m = 0; m < 3; m++) {
              if ((!faces[fGroup[l]].face_edges_dummy[m]) && (faces[fGroup[l]].face_edges_linked[m]) && (!faces[fGroup[l]].face_edges_flattened[m])) {
                  left_edges += 1
                  f_hinge_edge.push(m)
                  f_hinge.push(fGroup[l])

              }
          }
      }

      fGroup.splice(fGroup.indexOf(f_hinge[0]),1)

      fGroup.unshift(f_hinge[0])


      var result = [fGroup, boundary_Edge, left_edges, f_hinge, f_hinge_edge]
      return result
  }

  function remaining_Faces_Count(){
      var num = 0;
      for(var i = 0; i<faces.length;i++){
          if(faces[i].folded) num +=1
      }
      return num
  }
  async function recomputeEdgeUnfolding(selection) {

      await displayPolyhedron();

      for (var i =0; i<selection.length;i++) {
          //console.log("for loop :",i)

          var edge_object = group.getObjectByName("edge_" + selection[i])
          //console.log(edge_object)

          if(edges[edge_object.uuid].selected) edge_object.material = edgeMaterial;
          else edge_object.material = edgeMaterialSelected;

          edges[edge_object.uuid].selected = !edges[edge_object.uuid].selected;
          edge_object.material.needsUpdate = true;

          await liveUnfold(faces, edges, edge_object, edges[edge_object.uuid]);
      }

  }

  function getAngle(a,b){ // get angle between two vectors, assumethat two vectors are normalized vector

      var cosTheta = a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
      return 180 - Math.acos(cosTheta) / Math.PI * 180;
  }



  </script>


  </body>
</html>
